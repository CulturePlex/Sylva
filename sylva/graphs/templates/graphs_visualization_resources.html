{% load converter_filters compress %}

{# compress js #}
<script type="text/javascript">
  sylva.nodeViewURL = "{% url "nodes_view" graph.slug 0 %}";
  sylva.nodeEditURL = "{% url "nodes_edit" graph.slug 0 %}";
  {% if analytics %}
      sylva.is_graph_empty = JSON.parse('{{ is_graph_empty|escape_js }}');
      sylva.is_schema_empty = JSON.parse('{{ is_schema_empty|escape_js }}');
  {% else %}
    sylva.is_graph_empty = false;
    sylva.is_schema_empty = false;
  {% endif %}
  sylva.view_graph_ajax_url = "{{ view_graph_ajax_url }}";
  sylva.edit_nodetype_color_ajax_url = "{{ edit_nodetype_color_ajax_url }}";
  sylva.edit_reltype_color_ajax_url = "{{ edit_reltype_color_ajax_url }}";
  sylva.graph_analytics_boxes_edit_position = "{{ graph_analytics_boxes_edit_position }}";
</script>
<script type="text/javascript" src="{{ STATIC_PREFIX }}graphs/js/sigma/sigma.js"></script>
<script type="text/javascript" src="{{ STATIC_PREFIX }}graphs/js/sigma/plugins/sigma.layout.forceAtlas2.min.js"></script>
<script type="text/javascript" src="{{ STATIC_PREFIX }}graphs/js/sigma/plugins/sigma.parsers.gexf.min.js"></script>
<script type="text/javascript" src="{{ STATIC_PREFIX }}graphs/js/sigma/plugins/sigma.parsers.json.min.js"></script>
<script type="text/javascript" src="{{ STATIC_PREFIX }}graphs/js/sigma/plugins/sigma.plugins.animate.min.js"></script>
<script type="text/javascript" src="{{ STATIC_PREFIX }}graphs/js/sigma/plugins/sigma.plugins.dragNodes.min.js"></script>
<script type="text/javascript" src="{{ STATIC_PREFIX }}graphs/js/sigma/plugins/sigma.plugins.neighborhoods.min.js"></script>
<script type="text/javascript" src="{{ STATIC_PREFIX }}graphs/js/sigma/plugins/sigma.renderers.customShapes.min.js"></script>

<script type="text/javascript" src="{{ STATIC_PREFIX }}js/jquery-ui-1.10.4.js"></script>
<script type="text/javascript" src="{{ STATIC_PREFIX }}graphs/js/jquery/jquery.simulate.js"></script>

<script type="text/javascript" src="{{ STATIC_PREFIX }}js/jquery.simplemodal-1.4.4.js"></script>

<script type="text/javascript" src="{{ STATIC_PREFIX }}graphs/js/colpick/colpick.js"></script>
<script type="text/javascript" src="{{ STATIC_PREFIX }}graphs/js/colpick/rgbcolor.js"></script>
<script type="text/javascript" src="{{ STATIC_PREFIX }}graphs/js/jquery/jquery.xcolor.js"></script>

<script type="text/javascript" src="{{ STATIC_PREFIX }}graphs/js/paper/paper-core.min.js"></script>

<script type="text/javascript" src="{{ STATIC_PREFIX }}graphs/js/visualizations.js"></script>
<script type="text/javascript" src="{{ STATIC_PREFIX }}graphs/js/sigma-visualization.js"></script>
<script type="text/javascript" src="{{ STATIC_PREFIX }}graphs/js/modals.js"></script>
{# endcompress #}

{% compress css %}
<link type="text/css" rel="stylesheet" href="{{ STATIC_PREFIX }}css/jqueryui.1.8.18.css" />
<link type="text/css" rel="stylesheet" href="{{ STATIC_PREFIX }}graphs/css/colpick/colpick.css" />
<link type="text/css" rel="stylesheet" href="{{ STATIC_PREFIX }}graphs/css/colpick/colpick.mod.css" />
{% endcompress %}

{% if OPTIONS.ENABLE_ANALYTICS %}
<!-- Begin code for the analytics side -->
{% compress js %}
<script type="text/javascript" src="{{ STATIC_PREFIX }}graphs/js/highcharts/highcharts.js"></script>
<script type="text/javascript" src="{{ STATIC_PREFIX }}graphs/js/highcharts/exporting.js"></script>
<script type="text/javascript" src="{{ STATIC_PREFIX }}js/moment.min.js"></script>
{% endcompress %}
<script type="text/javascript">

// Variable to store the ids to plot the results of the analytics
var analyticsName = {
  "connected_components": gettext("Connected components"),
  "triangle_counting": gettext("Triangle counting"),
  "graph_coloring": gettext("Graph coloring"),
  "betweenness_centrality": gettext("Betweenness centrality"),
  "pagerank": gettext("Pagerank"),
  "kcore": gettext("Degeneracy (k-core)")
};

// Variable to store the text to plot the x axis
var analyticsAxis = {
  "connected_components": gettext("Connected components"),
  "triangle_counting": gettext("Triangles"),
  "graph_coloring": gettext("Colors"),
  "betweenness_centrality": gettext("Betweenness centrality"),
  "pagerank": gettext("Pagerank"),
  "kcore": gettext("Degeneracy (k-core)")
};

// Variable to store the text to plot in the pie charts
var analyticsPieSubtitle = {
  "connected_components": gettext("connected components"),
  "graph_coloring": gettext("colors"),
}

// Variable to store the analytics that actually are executing
var analyticsExecuting = new Array();

var analyticsId = {};
var taskTime = 0;

(function($) {
      /**
      * AJAX Setup for CSRF Django token
      */
    $.ajaxSetup({
         beforeSend: function(xhr, settings) {
             function getCookie(name) {
                 var cookieValue = null;
                 if (document.cookie && document.cookie != '') {
                     var cookies = document.cookie.split(';');
                     for (var i = 0; i < cookies.length; i++) {
                         var cookie = jQuery.trim(cookies[i]);
                         // Does this cookie string begin with the name we want?
                     if (cookie.substring(0, name.length + 1) == (name + '=')) {
                         cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                         break;
                     }
                 }
             }
             return cookieValue;
             }
             if (!(/^http:.*/.test(settings.url) || /^https:.*/.test(settings.url))) {
                 // Only send the token to relative URLs i.e. locally.
                 xhr.setRequestHeader("X-CSRFToken", getCookie('csrftoken'));
             }
         }
    });

    var getHighchartsOptions = function(option, algorithm, parentArray) {
      var highchartsOptions = "";
      if(option == "scatter") {
        highchartsOptions = {
            chart: {
                renderTo: analyticsId[algorithm],
                type: 'scatter'
            },
            title: {
                text: analyticsName[algorithm]
            },
            xAxis: {
                title: {
                    text: analyticsAxis[algorithm]
                }
            },
            yAxis: {
                title: {
                    text: 'Nodes'
                }
            },
            plotOptions: {
                scatter: {
                    marker: {
                        radius: 5,
                        states: {
                            hover: {
                                enabled: true,
                                lineColor: 'rgb(100,100,100)'
                            }
                        }
                    },
                    states: {
                        hover: {
                            marker: {
                                enabled: false
                            }
                        }
                    },
                    tooltip: {
                        headerFormat: '',
                        pointFormat: '{point.y} with {point.x} ' + analyticsAxis[algorithm] + ''
                    }
                }
            },
            series: [{
              showInLegend: false,
              color: 'rgba(223, 83, 83, .5)',
              data: parentArray
            }]
        };
      } else if (option == "pie") {
        highchartsOptions = {
          chart: {
            renderTo: analyticsId[algorithm],
            plotBackgroundColor: null,
            plotBorderWidth: 1,
            plotShadow: false
          },
          title: {
              text: analyticsName[algorithm]
          },
          subtitle: {
            text: "Set of " + analyticsPieSubtitle[algorithm] + " of the graph"
          },
          tooltip: {
              headerFormat: '',
              showInLegend: false,
              pointFormat: '{series.name}: <b>{point.y}</b>'
          },
          plotOptions: {
              pie: {
                  allowPointSelect: true,
                  cursor: 'pointer',
                  dataLabels: {
                      enabled: true,
                      format: '{point.percentage:.1f}% ' + gettext("of nodes"),
                      style: {
                          color: (Highcharts.theme && Highcharts.theme.contrastTextColor) || 'black'
                      }
                  }
              }
          },
          series: [{
              type: 'pie',
              showInLegend: false,
              name: 'Number of nodes',
              data: parentArray
          }]
        };
      }

      return highchartsOptions;
    };

    // get results of the analytic
    var getResults = function(results_url, algorithm, analyticId, analyticTaskStart) {
      $.ajax({
          type: "GET",
          dataType: 'json',
          url: results_url,
          success: function (data) {
            var chartType = "";
            var parentArray = new Array();
            var highchartPieOption = algorithm == "connected_components" ||
                                     algorithm == "graph_coloring";
            if(highchartPieOption) {
              chartType = "pie";
              for(var i in data) {
                var childArray = new Array();
                childArray.push(parseFloat(i));
                childArray.push(data[i]);
                parentArray.push(childArray);
              }
            } else {
              chartType = "scatter";
              for(var i in data) {
                var childArray = new Array();
                childArray.push(parseFloat(i));
                childArray.push(data[i]);
                parentArray.push(childArray);
              }
            }

            // Create the chart
            optionsScatter = getHighchartsOptions(chartType, algorithm, parentArray);
            var chart = new Highcharts.Chart(optionsScatter);

            // We hide the estimated time and the progress bar
            etaId = '#' + algorithm +"-eta";
            progressBarId = '#progress-bar-' + algorithm;
            $(etaId).html("");
            $(progressBarId).css({
              "display": "none"
            });
            $(progressBarId).attr('value', 0);

            if(analyticId != "") {
              selectAnalyticsId = '#last-analytics-' + algorithm;
              $(selectAnalyticsId).prepend("<option value=" + analyticId + " selected>" + gettext(moment.duration(-1, "seconds").humanize(true)) + "</option>");
              $(selectAnalyticsId).css({
                'display': 'inline-block'
              })
            }
          },
          error: function () {
              alert("Error");
          }
      });
    }

    // pole state of the current task
    var getTaskState = function(analyticsExecuting, progressBarId) {
      progressBarMax = $(progressBarId).attr('max');
      analyticsRequest = JSON.stringify(analyticsExecuting);
      $.ajax({
        type: "GET",
        url: "{% url 'analytics_status' graph.slug %}",
        data: {"analytics_request": analyticsRequest}
      }).done(function(analyticsResults){
        // If we have finished analytics, we show them
        for(key in analyticsResults) {
          if(analyticsResults.hasOwnProperty(key)) {
            resultsUrl = analyticsResults[key][0];
            analyticId = analyticsResults[key][1];
            analyticTaskStart = analyticsResults[key][2];
            algorithm = analyticsResults[key][3];
            getResults(resultsUrl, algorithm, analyticId, analyticTaskStart);
            $(progressBarId).attr('value', 100);
            // We remove the element of the list of analytics executing
            var index = analyticsExecuting.indexOf(key);
            if(index > -1)
              analyticsExecuting.splice(index, 1);
            // If we dont have more analytics executing, we reset the time for the progress bars
            if(analyticsExecuting.length == 0)
              taskTime = 0;
          }
        }
        if(analyticsExecuting.length > 0) {
            // We ask for the analytics until all of them are finished
            window.setTimeout(function() {
              getTaskState(analyticsExecuting, progressBarId);
            }, 1000);
            if(taskTime < progressBarMax) {
              taskTime = taskTime + 7;
              $(progressBarId).attr('value', taskTime);
            }
        }
        // create the infinite loop of Ajax calls to check the state
        // of the current task
      });
    }

    $('.play-algorithm').on('click', function() {
        var $this = $(this);
        var measure = $this.data('measure');
        var plotId = $this.data('plot');
        var etaId = $this.data('eta');
        var progressBarId = "#progress-bar-" + measure;

        analyticsId[measure] = plotId;
        $('#' + etaId).html(gettext("Estimating time"));

        jQuery.ajax({
            type: "POST",
            url: "{% url 'analytics_estimate' graph.slug %}",
            data: {"algorithm": measure}
        }).done(function(data){
            var algorithm = data[0];
            var etaTime = data[1];
            if(etaTime < 10) {
              $(progressBarId).attr('max', 100);
            } else {
              $(progressBarId).attr('max', 300);
            }
            $('#' + etaId).html(gettext("Estimated time ") + etaTime.toFixed(2) + gettext(" seconds"));
            jQuery.ajax({
            type: "POST",
            url: "{% url 'analytics_run' graph.slug %}",
            data: {"algorithm": measure}
            }).done(function(data){
                var taskId = data[0];
                var algorithm = data[1];
                analyticsExecuting.push(taskId);
                getTaskState(analyticsExecuting, progressBarId);
                $(progressBarId).css({
                  'display': 'inline-block'
                });
            });
        });
    });

    $('.analytics-measure').accordion({
      collapsible: true,
      create: function(event, ui) {
        var box = $(event.target);
        var children = box.children();
        var header =  children.first();
        var body = $(children[1]);
        var span = header.children().first();

        // The next lines remove jQueryUI style from the boxes.
        box.removeClass('ui-widget ui-accordion');
        header.removeClass('ui-accordion-icons ' +
          'ui-accordion-header ui-helper-reset ui-state-default');
        body.removeClass('ui-accordion-content ui-widget-content');
        body.css('height', '');
        span.remove();
      },
      active: false,
      heightStyle: 'content'
    });

    $(document).on('change', '.last-analytics', function() {
      var $this = $(this);
      var analyticId = $('option:selected', $this).val();

      $.ajax({
        type: "GET",
        url: "{% url 'analytics_analytic' graph.slug %}",
        data: {"id": analyticId}
      }).success(function(result){
        var resultsUrl = result[0];
        var algorithm = result[1];

        // We check if we have defined the id for render highcharts
        if(!analyticsId[algorithm]) {
          analyticsId[algorithm] = algorithm + "-results";
        }

        console.log(resultsUrl);
        console.log(algorithm);
        getResults(resultsUrl, algorithm, "", "");

        /* A function for update the selected nodes in the graph using the
         * analytic implied nodes.
         */
        var updateGraph = function(nodes) {
          var arrayNodes = nodes.split("\n"); // Text as array of strings.
          var newNodes = arrayNodes.slice(line + 1); // Only the 'new' nodes.

          newNodes.forEach(function(nodeId) {
            if (nodeId.length > 0) { // Removing enmpty lines.
              sylva.selectedNodes.push(JSON.parse(nodeId));
              line += 1;
            }
          });
          sylva.Sigma.grayfyNonListedNodes(sylva.selectedNodes);
        };

        // Getting the implied nodes.
        sylva.selectedNodes = []; // Cleaning the selection.
        var line = -1; // The index for 'random access'.
        jqxhr= $.ajax({
          type: "GET",
          url: "{% url 'analytics_dump' graph.slug %}",
          data: {"id": analyticId},
          xhr: function() {
            /* A way for react to changes of the request.
             *
             * The main thing is the state of the 'xhr' object.
             *    0: request not initialized
             *    1: server connection established
             *    2: request received
             *    3: processing request
             *    4: request finished and response is ready
             *
             * Using the method 'onprogress' (there are others, but this is
             * which we need) we can check the state of the request when there
             * are changes.
             * So, we need to check the state '3' and '4' ('4' is like 'done'
             * or 'success').
             *
             * So, while the original 'xhr' object is maintained, we are
             * changing the 'onprogress' value, which previously was 'null'.
             */
            var xhr = $.ajaxSettings.xhr();
            xhr.onprogress = function() {
              if (xhr.status == 200 && xhr.readyState > 2) {
                updateGraph(xhr.response);
              }
            };
            return xhr;
          }
        })
        .error(function(err) {
          console.log("AJAX error in request: " + JSON.stringify(err, null, 2));
        });

      });
    });

    $('#analytics-algorithms').sortable();
})(jQuery);
</script>
<!-- End code for the analytics side -->
{% endif %}
